<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_92) on Fri Aug 18 15:52:10 CEST 2017 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>com.martinandersson.javaee.cdi.packaging (Java EE Concepts 1.0.0-SNAPSHOT Test API)</title>
<meta name="date" content="2017-08-18">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.martinandersson.javaee.cdi.packaging (Java EE Concepts 1.0.0-SNAPSHOT Test API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../com/martinandersson/javaee/cdi/lookup/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../com/martinandersson/javaee/cdi/packaging/lib/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?com/martinandersson/javaee/cdi/packaging/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;com.martinandersson.javaee.cdi.packaging</h1>
<div class="docSummary">
<div class="block">Summary</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../com/martinandersson/javaee/cdi/packaging/ExplicitPackageTest.html" title="class in com.martinandersson.javaee.cdi.packaging">ExplicitPackageTest</a></td>
<td class="colLast">
<div class="block">This test will package an empty <code>beans.xml</code> descriptor file in the
 deployment archive, meaning that the archive is an "explicit bean archive" in
 which all classes are eligible for CDI management.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../com/martinandersson/javaee/cdi/packaging/ImplicitPackageInvalidTest.html" title="class in com.martinandersson.javaee.cdi.packaging">ImplicitPackageInvalidTest</a></td>
<td class="colLast">
<div class="block">This test will not package a <code>beans.xml</code> descriptor file in the
 deployment archive, meaning that the archive is an "implicit bean archive" in
 which only annotated beans are eligible for CDI management.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../com/martinandersson/javaee/cdi/packaging/ImplicitPackageValidTest.html" title="class in com.martinandersson.javaee.cdi.packaging">ImplicitPackageValidTest</a></td>
<td class="colLast">
<div class="block">This test will not package a <code>beans.xml</code> descriptor file in the
 deployment archive, meaning that the archive is an "implicit bean archive" in
 which only annotated beans are eligible for CDI management.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package com.martinandersson.javaee.cdi.packaging Description">Package com.martinandersson.javaee.cdi.packaging Description</h2>
<div class="block"><h2>Summary</h2>
 
 You may package an empty <code>beans.xml</code> for possible discovery of all
 bean classes including unannotated ones, or you may include contents in the
 file but if so, you must specify a <code>bean-discovery-mode</code> of <code>none</code>, <code>annotated</code> or <code>all</code>. If you don't package the file with
 your application, then the archive will be processed but only annotated beans
 will be discovered.<p>
 
 
 
 <h2>Order of study</h2>
 
 <ol>
   <li>Read through this file, then..</li>
   <li><a href="../../../../../com/martinandersson/javaee/cdi/packaging/ExplicitPackageTest.html" title="class in com.martinandersson.javaee.cdi.packaging">ExplicitPackageTest.java</a></li>
   <li><a href="../../../../../com/martinandersson/javaee/cdi/packaging/ImplicitPackageValidTest.html" title="class in com.martinandersson.javaee.cdi.packaging">ImplicitPackageValidTest.java</a></li>
   <li><a href="../../../../../com/martinandersson/javaee/cdi/packaging/ImplicitPackageInvalidTest.html" title="class in com.martinandersson.javaee.cdi.packaging">ImplicitPackageInvalidTest.java</a></li>
 </ol><p>
 
 
 
 <h2>Packaging modern CDI applications (Java EE 7)</h2>
 
 There are three types of bean archives:
 
 <ol>
   <li>Not a bean archive</li>
   <li>Explicit bean archive</li>
   <li>Implicit bean archive</li>
 </ol>
 
 If an archive is <strong>not a bean archive</strong>, then the CDI container
 cannot, or rather, will not manage stuff put in the archive. For
 <strong>explicit bean</strong> archives, everything in the archive is
 eligible for management and may be used as an injectable component unless the
 bean/class itself has been annotated
 @javax.enterprise.inject.Vetoed.
 For <strong>implicit archives</strong>, CDI only manage beans that has an
 explicit "bean defining annotation". This annotation is a scope type such as
 @javax.enterprise.context.RequestScoped.
 <p>
 
 In CDI 1.0, it was not apparent what exactly a "bean defining annotation"
 is. WildFly 8.1.0 and my own understanding of all related Java EE
 specifications<sup>1</sup> also define the "base model" annotation
 <a href="http://docs.oracle.com/javase/8/docs/api/javax/annotation/ManagedBean.html?is-external=true" title="class or interface in javax.annotation">@javax.annotation.ManagedBean</a> as
 a "bean defining annotation". GlassFish however don't and will crash if one
 try to inject a <code>@ManagedBean</code> from an implicit bean archive.<p>
 
 Do note that explicit archives do not require explicit bean annotations,
 implicit archives do. That is like totally inverted so one might think that
 the expert group (many times referred to using the acronym "EG") behind the
 specification were all high when they made up the archive definitions.
 Instead of making changes for the better, CDI 1.2 want to "add clarification"
 and by doing so, add yet another definition to the stack<sup>2</sup>:
 <pre><code>
     A bean class with a bean defining annotation is said to be an implicit
     bean.
 </code></pre>
 
 All sane persons should agree that replacing magic with real annotations on a
 class make the bean "explicit" and not the other way around. However, I think
 that the chosen terminology has to do with the possible requirement of a
 <code>beans.xml</code> descriptor file. Explicit archives require the file,
 implicit archives don't. That whole annotation-thing is probably just an
 unfortunate mismatch. An error multiplied with the new term "implicit bean"
 added in CDI 1.2.<p>
 
 You know by now the effects of the different archive types; whether or not
 beans in these archives are discovered. Next, we'll dig deeper into what
 constitutes the different archive types. Inevitably, the <code>beans.xml</code>
 file will be referred to many times over. A <code>beans.xml</code> skeleton and a
 good reference to have open during the rest of today's reading can be found
 here:
 <pre><code>
     http://docs.oracle.com/javaee/7/tutorial/doc/cdi-adv001.htm
 </code></pre>
 
 
 
 <h3>The not a bean archive archive</h3>
 
 A EAR package is not a "module", and can therefore not be a bean
 archive<sup>3</sup>. A bean archive must be a JAR-, WAR- or RAR package.
 These files in turn may be packaged as modules within an EAR file which is
 another thing.<p>
 
 Technically speaking, an archive with no classes in it or an archive that
 contain only classes CDI cannot use (abstract classes for example) cannot be
 a "bean archive".<p>
 
 An archive is not a bean archive if the <code>beans.xml</code> descriptor file has
 been provided and attribute <code>bean-discovery-mode</code> of the root element
 <code>&lt;beans&gt;</code> has been set to <code>none</code>. Value "none" mean that the
 container will not look for beans in the archive as opposed to the other two
 possible values: "annotated" and "all".<p>
 
 An archive that does not bundle the <code>beans.xml</code> descriptor file is an
 implicit bean archive, unless the archive also contains a CDI extension. If
 the archive contains an extension, the archive will become a "not a bean
 archive archive" that CDI ignore.<p>
 
 
 
 <h3>Explicit bean archives</h3>
 
 If the archive has a <code>beans.xml</code> descriptor file bundled with it, and
 this file is either 1) empty or 2) <code>bean-discovery-mode</code> has been set
 to <code>all</code>, then the archive is an explicit bean archive. As described
 previously, all classes in such an archive is a possible candidate for CDI
 management. This is the most used packaging strategy - for better or worse.<p>
 
 
 
 <h3>Implicit bean archives</h3>
 
 Any other archive that has not previously been described is said to be an
 implicit bean archive. This basically only leave us with two cases: either
 the archive has no <code>beans.xml</code> file or one is present but <code>bean-discovery-mode</code> has been set to <code>annotated</code>.<p>
 
 By definition therefore, pritty much all archives used in modern web
 applications, which lack the <code>beans.xml</code> file, are implicit bean
 archives; processed by the CDI container in a hunt for annotated beans he can
 manage and make use of. If you're a good sport that make use of annotations,
 then you don't have to bother about the <code>beans.xml</code> file either.<p>
 
 The CDI 1.1 specification has a twist in store when it comes to defining an
 "implicit bean archive". Section 12.1 says:
 <pre><code>
     "An implicit bean archive is any other archive which contains one or more
      [..] session beans."
 </code></pre>
 
 What implication this has for the reality, apart from what already define an
 implicit bean archive as outlined above, is beyond what I can comprehend.<p>
 
 
 <h3>In which path should we put beans.xml?</h3>
 
 The answer is straight forward. CDI 1.1 specification, section 12.1:
 <pre><code> 
 
     "The beans.xml file must be named:
 
      • META-INF/beans.xml , or,
      • in a war, WEB-INF/beans.xml or WEB-INF/classes/META-INF/beans.xml.
 
      If a war has a file named beans.xml in both the WEB-INF directory and in
      the WEB-INF/classes/META-INF directory, then non-portable behavior
      results. Portable applications must have a beans.xml file in only one of
      the WEB-INF or the WEBINF/classes/META-INF directories."
 
 </code></pre>
 
 It is important to note the first paragraph of the previous "not a bean
 archive archive" section: EAR files are not modules and cannot be bean
 archives. Putting "META-INF/beans.xml" directly in an EAR file make no sense.
 Therefore, the first bullet point in the previous quote applies only to JAR-
 and RAR files.<p>
 
 
 
 <h3>The version and discovery mode dilemma</h3>
 
 Some sources, of which the CDI 1.1 specification itself is one, trouble
 themselves by adding complexity to the previously described archive types.
 The Java EE 7 tutorial linked earlier says:
 <pre><code>
     "An explicit bean archive is an archive that contains a beans.xml
      deployment descriptor, which can [..] contain no version number, or
      contain the version number 1.1 with the bean-discovery-mode attribute
      set to all."
 </code></pre>
 
 This quote probably originate from the CDI 1.1 specification (section 12.1):
 <pre><code>
     "An explicit bean archive is an archive which contains a beans.xml file
      with a version number of 1.1 (or later), with the bean-discovery-mode of
      all [and so forth..]"
 </code></pre>
 
 These two quotes indicate that the version number is of utmost importance and
 that the <code>bean-discovery-mode</code> attribute has to be particularly
 customized for different versions.<p>
 
 However, the <code>beans.xml</code> file cannot have "no version number" because
 if the version attribute is left out, it defaults to version
 "1.1"<sup>4</sup>. Furthermore, attribute <code>bean-discovery-mode</code> must be
 specified because it is required by the XML schema definition<sup>4</sup>
 (the specification says this attribute has a default value "annotated" which
 is false). Version 1.0 of <code>beans.xml</code> do not define the attribute
 <code>bean-discovery-mode</code><sup>5</sup>. Adding that would be an error, at
 least if you stick to the old schema file which is exactly what you'll most
 likely be doing if you use version 1.0.<p>
 
 
 
 
 
 <h2>Packaging legacy archives (Java EE 6)</h2>
 
 "Implicit", "explicit" and "discovery mode" are are all new concepts
 introduced in CDI 1.1 (Java EE 7). CDI 1.0 (Java EE 6) has no clue about
 them.<p>
 
 Here's the deal about that one. Once upon time, all developers wrote EJB:s
 and POJO:s they thought suited well as CDI managed beans. Then came
 deployment time and only EJB:s gave up a sign of life. Nothing at all
 happened with the precious CDI beans that was packaged with the archive too.
 Many developers wasted many hours trying to debug the situation until they
 discovered that CDI 1.0 require "a file named beans.xml" (section 12.1).
 Hence, the archive is required to be an "explicit archive" using modern
 terminology.<p>
 
 The expert group behind CDI 1.0 had been a bit afraid that the server would
 have to do to much work, scanning and process too many classes for nothing -
 had the requirement of the file not been there. It turned out though that the
 absolute majority of all developers used CDI which today is somewhat of a
 core service in all back-end software. Moreover, most deployments are quite
 small and processing classes in them take no time at all. So the only effect
 of this "premature optimization" was a waste of time for a shitload of
 developers.<p>
 
 CDI 1.0 doesn't comment whether or not the file may be empty, only that a
 file had to be there. But servers kind of picked up on that and began
 processing the archives as long as a file literally was packaged with the
 archive even though it might be completely empty. CDI 1.1 has continued the
 tradition and declared the "empty file" as having marked an "explicit
 archive" in which all classes are processed.<p>
 
 So, packaging a legacy archive doesn't differ to much from modern packaging
 strategies. Just make sure an empty <code>beans.xml</code> file is present and the
 end result will be the same no matter CDI version. However, modern
 deployments using CDI 1.1 can optionally leave out the file altogether and
 still have annotated beans processed. But be vary that trying to deploy a
 modern archive with no <code>beans.xml</code> file to an old server might not
 cause any deployment issues
 (DeploymentException),
 but it will cause the injection of fields in your application to not work
 properly (NullPointerException).<p>
 
 
 
 <h3>Note 1</h3>
 CDI 1.1 (JSR-346) only define <code>@ManagedBean</code> as a "bean defining
 annotation" implicitly. For more information:
 <pre><code> 
     http://stackoverflow.com/questions/25327057
 </code></pre>
 
 If you haven't already, read through the concept of "managed beans" explained
 in file:
 <pre><code> 
     ./com/martinandersson/javaee/cdi/package-info.java&lt;p&gt;
 </code></pre><p>
 
 
 <h3>Note 2</h3>
 See section "2.5.1. Bean defining annotations" in:
 <pre><code>
     http://docs.jboss.org/cdi/spec/1.2/cdi-spec-1.2.pdf
 </code></pre>
 
 <h3>Note 3</h3>
 See Java EE 7 specification (JSR-342) chapter EE.8 and CDI 1.1 specification
 (JSR-346) section 5.1.
 
 
 <h3>Note 4</h3>
 See the XML schema definition file here:
 <pre><code>
     http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd
 </code></pre>
 
 
 <h3>Note 5</h3>
 See the XML schema definition file here:
 <pre><code>
     http://java.sun.com/xml/ns/javaee/beans_1_0.xsd
 </code></pre></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../com/martinandersson/javaee/cdi/lookup/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../com/martinandersson/javaee/cdi/packaging/lib/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?com/martinandersson/javaee/cdi/packaging/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2017. All rights reserved.</small></p>
</body>
</html>
